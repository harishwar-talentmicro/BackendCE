/**
 * @author Indra Jeet
 * @desc Citrus Payment Gateway Wrapper class for NodeJs
 *
 * @dependency
 * 1. random-string
 * 2. crypto
 * 3. path
 * 4. querystring
 *
 * @table-structure citrus_payment
 * id <int> Autogenerated id
 * tx_id <varchar> Unique transactionId [length : 25]
 * amount <float> Amount to be paid (two decimal places only)
 * currency <varchar> Currency Code [length : 10]
 * tx_signature <varchar> Transaction Signature (Checksum for transaction) [length : 50]
 * status <int> (0 : Pending, 1 : Successful, 2 : Cancelled)
 * tx_ref_no <varchar> Citrus pay transaction reference number [length : 255]
 * tx_status <varchar> Citrus pay transaction status [length : 255]
 * tx_msg <text> Citrus pay transaction message
 * pg_txn_no <varchar> Citrus PaymentGateway or PG Transaction Id [length : 255]
 * issuer_ref_no <varchar> Citrus Issuer reference number (Unique txId or PaymentGateway or PG Generated txId) [length : 255]
 * auth_id_code <varchar> Citrus Bank or PaymentGateway or PG Generated Unique Authorized ID [length : 255]
 * first_name <varchar> First Name of the user who is paying
 * last_name <varchar> Last Name of the user who is paying
 * pg_resp_code <varchar> Citrus Response code for status of transaction
 * address_zip <text> Consumer Address ZIP
 * cr_date <timestamp> Created Timestamp
 * lu_date <timestamp> Last updated timestamp
 *
 */

var randomString = require('random-string');
var crypto = require('crypto');
var path = require('path');
var qs = require('querystring');

/**
 * Pad any number with zeroes to the left hand side based on padding
 * @param number <int>
 * @param padding <int>
 * @returns {string}
 */
function padWithZero(number,padding){
    var returnStr = "";
    if(number){
        returnStr = number.toString();
        for(var i=0; i < (padding - number.toString().length); i++){
            returnStr = '0'+returnStr;
        }
    }
    return returnStr;
};


const PAYMENT_CONFIG = require(path.join(__dirname + '../../payment-config.json'));
function CitrusPayment(){};

/**
 * Generates transaction signature for payment
 * @param txId <string>
 * @param amount <float>
 */
CitrusPayment.prototype.generateTxSignature = function(txId,amount){
    var hmac = crypto.createHmac('sha1',PAYMENT_CONFIG.SECRET_KEY);
    var dataStr = CONFIG.VANITY_URL_PART + amount + txId  +  + CONFIG.CURRENCY;
    hmac.update(dataStr);
    return hmac.digest('hex');
};

/**
 * Generates unique transactionId based on orderId for payment
 * @param orderId <int>
 * @returns {*}
 */
CitrusPayment.prototype.generateUniqueTxId = function(orderId){
    if(orderId){
        return Date.now() + 'fm' + padWithZero(orderId,10);
    }
    return null;
};

/**
 * Payment Initialization process begins here
 * Calling this function will generate object with following properties and values that will be submitted to citrus url by front end form
 * @param orderId <int>
 * @param amount <float>
 * @returns {{merchantTxnId, orderAmount: string, currency: *, secSignature, returnUrl: *, notifyUrl: *}}
 */
CitrusPayment.prototype.initiatePayment = function(orderId,amount){
    var _this = this;
    var txId = _this.generateUniqueTxId();
    var txDetails = {
        merchantTxnId : txId,
        orderAmount : amount.toFixed(2),
        currency : CONFIG.CURRENCY,
        secSignature : _this.generateTxSignature(txId,amount.toFixed(2)),
        returnUrl : CONFIG.RETURN_URL,
        notifyUrl : CONFIG.NOTIFY_URL
    };
    return txDetails;
};

/**
 * Parses the payment data that came from citrus payment gateway on completion
 * of payment process and return a standard object containing all the attributes with values
 * @param paymentData <object>
 * @returns {*}
 */
CitrusPayment.prototype.parsePaymentData = function(paymentData){
    var parsedPaymentData = null;
    if(paymentData){
        parsedPaymentData = {};
        if(paymentData['pgRespCode']){
            paymentData['pgRespCode'] = parseInt(paymentData['pgRespCode']);
            switch(paymentData['pgRespCode']){
                case 0 :
                    parsedPaymentData.paymentMessage = PAYMENT_CONFIG.MESSAGE[0];
                    parsedPaymentData.respStatus = 1;
                    break;
                case 1 :
                    parsedPaymentData.respType = PAYMENT_CONFIG.MESSAGE[1];
                    parsedPaymentData.respStatus = 0;
                    break;
                case 2 :
                    parsedPaymentData.respType = PAYMENT_CONFIG.MESSAGE[2];
                    parsedPaymentData.respStatus = 0;
                    break;
                case 3 :
                    parsedPaymentData.respType = PAYMENT_CONFIG.MESSAGE[3];
                    parsedPaymentData.respStatus = 0;
                    break;
                case 4 :
                    parsedPaymentData.respType = PAYMENT_CONFIG.MESSAGE[4];
                    parsedPaymentData.respStatus = 0;
                    break;
                case 5 :
                    parsedPaymentData.respType = PAYMENT_CONFIG.MESSAGE[5];
                    parsedPaymentData.respStatus = 0;
                    break;
                case 6 :
                    parsedPaymentData.respType = PAYMENT_CONFIG.MESSAGE[6];
                    parsedPaymentData.respStatus = 0;
                    break;
                case 7 :
                    parsedPaymentData.respType = PAYMENT_CONFIG.MESSAGE[7];
                    parsedPaymentData.respStatus = 0;
                    break;
                case 8 :
                    parsedPaymentData.respType = PAYMENT_CONFIG.MESSAGE[8];
                    parsedPaymentData.respStatus = 0;
                    break;
                case 9 :
                    parsedPaymentData.respType = PAYMENT_CONFIG.MESSAGE[9];
                    parsedPaymentData.respStatus = 0;
                    break;
                case 10 :
                    parsedPaymentData.respType = PAYMENT_CONFIG.MESSAGE[10];
                    parsedPaymentData.respStatus = 0;
                    break;
                case 11 :
                    parsedPaymentData.respType = PAYMENT_CONFIG.MESSAGE[11];
                    parsedPaymentData.respStatus = 0;
                    break;
                case 12 :
                    parsedPaymentData.respType = PAYMENT_CONFIG.MESSAGE[12];
                    parsedPaymentData.respStatus = 0;
                    break;
                case 13 :
                    parsedPaymentData.respType = PAYMENT_CONFIG.MESSAGE[13];
                    parsedPaymentData.respStatus = 2;
                    break;
                case 14 :
                    parsedPaymentData.respType = PAYMENT_CONFIG.MESSAGE[14];
                    parsedPaymentData.respStatus = 2;
                    break;
                case 15 :
                    parsedPaymentData.respType = PAYMENT_CONFIG.MESSAGE[15];
                    parsedPaymentData.respStatus = 0;
                    break;
                case 16 :
                    parsedPaymentData.respType = PAYMENT_CONFIG.MESSAGE[16];
                    parsedPaymentData.respStatus = 0;
                    break;
                case 17 :
                    parsedPaymentData.respType = PAYMENT_CONFIG.MESSAGE[17];
                    parsedPaymentData.respStatus = 0;
                    break;
                default :
                    break;

            }
        }
    }
    return parsedPaymentData;
};

/**
 * When citrus redirects to merchant site i.e. our own site eg. ezeone.com then this function is called inside the redirect
 * url handler and parses data updates status in database and redirects to the transaction status of our own
 * site page to tell whether payment is successful or not
 * @param req
 * @param res
 * @param callback
 */
CitrusPayment.prototype.verifyPayment = function(req,res,callback){
    var _this = this;
    var requestBody = "";
    if (req.method = "POST") {
        req.on("data", function (data) { requestBody += data; });
        req.on("end", function () {
            try {
                var citrusRespData = qs.parse(requestBody);
                var dataStr = citrusRespData['TxId'] + citrusRespData['TxStatus'] + citrusRespData['amount']
                    + citrusRespData['pgTxnNo'] + citrusRespData['issuerRefNo'] + citrusRespData['authIdCode']
                    + citrusRespData['firstName'] + citrusRespData['lastName'] + citrusRespData['pgRespCode'] + citrusRespData['addressZip'];
                console.log(dataStr);
                var signature = crypto.createHmac('sha1', PAYMENT_CONFIG.SECRET_KEY).update(dataStr).digest('hex');
                if (signature == citrusRespData['signature']) {
                    console.log('Transaction Signature Verified');
                    var parsedPaymentData = _this.parsePaymentData(citrusRespData);
                    callback(parsedPaymentData,function(orderId){
                        res.redirect(CONFIG.PAYMENT_CONFIRM_WEBPAGE_URL +((orderId) ? "?oid="+orderId : ''));
                    });
                }
                else {
                    console.log('Transaction Signature Verification Failed');
                    callback(null,function(orderId){
                        res.redirect(CONFIG.PAYMENT_CONFIRM_WEBPAGE_URL +((orderId) ? "?oid="+orderId : ''));
                    });
                }
            }
            catch (err2) {
                console.log(err2);
                console.log('---------Payment return url body---------------------');
                console.log(requestBody);
                console.log('---------Payment return url body ends ---------------------');
                callback(null,function(){

                });
            }
        });
    }
    else{
        console.log('Payment redirect url is not posted with POST method');
        console.log('------------ Error from payment gateway ! Please check if payment api has changed or updated');
    }
};

module.exports = CitrusPayment;
